from pymongo import MongoClient
from pymongo.errors import OperationFailure
from Crypto.Hash import SHA
from Crypto.Hash import HMAC
from flask import Response

import logging
import json
import socket

class IndexDaemon(object):
    def __init__(self):
        client = MongoClient('localhost:27017')
        db = client['duckduckmongo']
        self.users = db['users']
        self.combined = db['combined']
        self.auth_types = ['X-Hub-Signature']
        self.sha1 = SHA.new()

    def handle(self, message, headers, env):
        authed = None, False
        if 'REMOTE_ADDR' not in env:
            return self.respond(412, status="a REMOTE_ADDR is required")
        for field in headers:
            if field[0] in self.auth_types:
                authed = self.authenticate(json.dumps(message), field[1], env['REMOTE_ADDR'])
        if not authed[1]:
            return self.respond(401)
        user = authed[0]
        source = user['full_name']
        id_field = user['id_field']
        _id = str(message[id_field])
        new_id = source + '-' + _id
        message.update({
            '_id': new_id,
            'source': source
        })
        if 'subsource' in user:
            message.update(dict(subsource=message[user['subsource']]))
        self.combined.update(dict(_id=new_id), message, True)
        return self.respond(200)

    # does this need to be salted? I doubt it
    def authenticate(self, msg, h, requester):
        result = self.users.find_one({'ip': requester})
        if not result or 'auth' not in result:
            return None, False
        token = str(result['auth']) # cannot be unicode
        hasher = HMAC.new(token, digestmod=self.sha1)
        hasher.update(msg)
        return result, (h == hasher.hexdigest()) # secure compare I suppose

    def respond(self, code, status=""):
        response = Response(mimetype="text/html")
        response.status_code = code
        if len(status) > 0:
            response.status = status
        return response

    def register(self, fullname, hostname, authtype, auth, id_field, subsource=None):
        if authtype not in self.auth_types:
            self.auth_types.append(authtype)
        user = {
            'full_name': fullname,
            'ip': socket.gethostbyname(hostname),
            'id_field': id_field,
            'auth': auth
        }
        if subsource:
            user.update({'subsource': subsource})
        # TODO: return an autogenerated config json
        try:
            result = self.users.insert(user)
            return (result is not None)
        except OperationFailure:
            return False
